!
      module atmos_chem_phy_cpl_comp_mod

!-----------------------------------------------------------------------
!
!** This module holds the chem-to-phys coupler's register and run routines
!** setservices (only registers run step) is called by GOCART_SETUP
!** run transfer/convert data from chem export state to phy export state
!
!! Code Revision:
!! 24Feb 2010     Sarah Lu, First Crack
!! 12Mar 2010     Sarah Lu, Use routines from phy2chem coupler
!! 16Mar 2010     Sarah Lu, Dimension and tracer specification are passed 
!!                          in from phy2chem coupler module; flip the 
!!                          vertical index from top-down to bottom-up
!! 09May 2010     Sarah Lu, Revise species name for SU, OC, and BC
!! 13May 2010     Sarah Lu, Gaseous species (DMS, SO2, MSA) are extracted 
!!                          from GOCART export state (not from AERO bundle)
!-----------------------------------------------------------------------

      use ESMF_MOD

      USE MODULE_ERR_MSG, ONLY: ERR_MSG, MESSAGE_CHECK
      use MODULE_gfs_machine,  ONLY: kind_phys
!
      use atmos_phy_chem_cpl_comp_mod, only:                  &
                          GetPointer_3D_,                     &
                          GetPointer_tracer_, CkPointer_,     &
                          lonr, lats_node_r, lats_node_r_max, &
                          lonsperlar_r, im, jm, km, ntrac,    &
                          run_DU, run_SU, run_SS, run_OC, run_BC

!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!
      public :: setservices

      contains

!
!-----------------------------------------------------------------------
!#######################################################################
!-----------------------------------------------------------------------
!
      subroutine setservices(GC, RC_REG)
!
!-----------------------------------------------------------------------
!!
!! This routine register the coupler component's run routine        
!!
!! Code Revision:
!! 24Feb 2009     Sarah Lu, First Crack
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!***  argument variables
!-----------------------------------------------------------------------
!
      type(ESMF_cplcomp),intent(inout) :: gc         ! coupler component
!
      integer,intent(out) :: rc_reg                  ! return code for register
!
!-----------------------------------------------------------------------
!***  local variables
!-----------------------------------------------------------------------
!
      integer :: rc=ESMF_success                     ! the error signal variable

!-----------------------------------------------------------------------
!***  register the coupler component's run routine
!-----------------------------------------------------------------------
!
      MESSAGE_CHECK="Set Entry Point for chem2phy coupler run"

      call ESMF_CplCompSetEntryPoint(GC                        & !<-- The gridded component
                                    ,ESMF_SETRUN               & !<-- Predefined subroutine type
                                    ,RUN                       & !<-- User's subroutineName
                                    ,ESMF_SINGLEPHASE          &
                                    ,rc)

      CALL ERR_MSG(RC,MESSAGE_CHECK,RC_REG)


!-----------------------------------------------------------------------
!***  Check the final error signal variable 
!-----------------------------------------------------------------------
!
      IF(RC_REG==ESMF_SUCCESS)THEN
        WRITE(0,*)'CHEM2PHY CPL SET_SERVICES SUCCEEDED'
      ELSE
        WRITE(0,*)'CHEM2PHY CPL SET_SERVICES FAILED RC_REG=',RC_REG
      ENDIF

!
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!
      end subroutine setservices


!-----------------------------------------------------------------------
!#######################################################################
!-----------------------------------------------------------------------
!
      subroutine run(GC, CHEM_EXP_STATE, PHY_EXP_STATE, CLOCK, RC_CPL)
!
!-----------------------------------------------------------------------
!!
!! This routine transfer/convert data from chem_exp state to phy_exp state
!!
!! Code Revision:
!! 24Feb 2010     Sarah Lu, First Crack
!-----------------------------------------------------------------------
!
      implicit none
!
!-----------------------------------------------------------------------
!***  argument variables
!-----------------------------------------------------------------------

      type(ESMF_cplcomp),intent(inout) :: GC
      type(ESMF_state),  intent(inout) :: CHEM_EXP_STATE   ! coupler import state
      type(ESMF_state),  intent(inout) :: PHY_EXP_STATE    ! coupler export state
      type(ESMF_clock),  intent(in)    :: CLOCK
!
      integer,           intent(out)   :: RC_CPL

!-----------------------------------------------------------------------
!***  local variables
!-----------------------------------------------------------------------
!
      integer                          :: rc=ESMF_success  ! the error signal variable
      integer                          :: item_count_phys, item_count_chem
      character(20)                    :: item_name(200)
      logical, save                    :: first =  .true.

! Fortran array for phy export state
      real (ESMF_KIND_R8), pointer, dimension(:,:,:) ::                  &
               p_du001, p_du002, p_du003, p_du004, p_du005,              & ! DU
               p_ss001, p_ss002, p_ss003, p_ss004, p_ss005,              & ! SS
               p_msa,   p_so4,   p_so2,   p_dms,                         & ! SU
               p_ocphobic, p_ocphilic, p_bcphobic, p_bcphilic              ! OC/BC
           
! Fortran array for chem export state
      real (ESMF_KIND_R8), pointer, dimension(:,:,:) ::                  &
               c_du001, c_du002, c_du003, c_du004, c_du005,              & ! DU
               c_ss001, c_ss002, c_ss003, c_ss004, c_ss005,              & ! SS
               c_msa,   c_so4,   c_so2,   c_dms,                         & ! SU
               c_ocphobic, c_ocphilic, c_bcphobic, c_bcphilic              ! OC/BC
!

!---------------------------------------------
!* Determine dimension and allocate local array 
!---------------------------------------------
!
      IF ( first ) THEN
!
! dimension/tracer setting is passed on from phy2chem coupler
!
        print *, 'CKS=>CHEM2PHY_RUN: im, jm, km=', im, jm, km
        print *, 'CKS=>CHEM2PHY_RUN: ntrac =', ntrac
        print *, 'CKS=>CHEM2PHY_RUN: doing_DU =', run_DU
        print *, 'CKS=>CHEM2PHY_RUN: doing_SU =', run_SU
        print *, 'CKS=>CHEM2PHY_RUN: doing_SS =', run_SS
        print *, 'CKS=>CHEM2PHY_RUN: doing_OC =', run_OC
        print *, 'CKS=>CHEM2PHY_RUN: doing_BC =', run_BC
        print *, 'CKS=>CHEM2PHY_RUN: lonr =', lonr
        print *, 'CKS=>CHEM2PHY_RUN: lats_node_r =', lats_node_r
        print *, 'CKS=>CHEM2PHY_RUN: lats_node_r_max =', lats_node_r_max
        print *, 'CKS=>CHEM2PHY_RUN: lonsperlar_r =', lonsperlar_r(:)

!       reset first flag
        first = .false.

      ENDIF

!---------------------------------------------
!* Get Fortran array from phy export state
!---------------------------------------------

      MESSAGE_CHECK="CHEM2PHY_RUN: Get ItemCount from phy export state"
      call ESMF_StateGet(PHY_EXP_STATE                    &
                        ,itemcount = item_count_phys      &
                        ,itemnamelist = item_name         &
                        ,rc   =rc)
      CALL ERR_MSG(RC,MESSAGE_CHECK,RC_CPL)

      IF ( RC == ESMF_SUCCESS ) THEN

      if (item_count_phys == 0 ) then

       print *, 'CHEM2PHY_RUN: Empty phy export state; Fortran array not filled'

      else

       if ( run_DU ) then
        call GetPointer_tracer_(PHY_EXP_STATE,'du001', p_du001, rc)
        call GetPointer_tracer_(PHY_EXP_STATE,'du002', p_du002, rc)
        call GetPointer_tracer_(PHY_EXP_STATE,'du003', p_du003, rc)
        call GetPointer_tracer_(PHY_EXP_STATE,'du004', p_du004, rc)
        call GetPointer_tracer_(PHY_EXP_STATE,'du005', p_du005, rc)
       endif

       if ( run_SS ) then
        call GetPointer_tracer_(PHY_EXP_STATE,'ss001', p_ss001, rc)
        call GetPointer_tracer_(PHY_EXP_STATE,'ss002', p_ss002, rc)
        call GetPointer_tracer_(PHY_EXP_STATE,'ss003', p_ss003, rc)
        call GetPointer_tracer_(PHY_EXP_STATE,'ss004', p_ss004, rc)
        call GetPointer_tracer_(PHY_EXP_STATE,'ss005', p_ss005, rc)
       endif

       if ( run_SU ) then
        call GetPointer_tracer_(PHY_EXP_STATE,'MSA', p_msa, rc)
        call GetPointer_tracer_(PHY_EXP_STATE,'SO4', p_so4, rc)
        call GetPointer_tracer_(PHY_EXP_STATE,'SO2', p_so2, rc)
        call GetPointer_tracer_(PHY_EXP_STATE,'DMS', p_dms, rc)
       endif

       if ( run_OC ) then
        call GetPointer_tracer_(PHY_EXP_STATE,'OCphobic', p_ocphobic, rc)
        call GetPointer_tracer_(PHY_EXP_STATE,'OCphilic', p_ocphilic, rc)
       endif

       if ( run_BC ) then
        call GetPointer_tracer_(PHY_EXP_STATE,'BCphobic', p_bcphobic, rc)
        call GetPointer_tracer_(PHY_EXP_STATE,'BCphilic', p_bcphilic, rc)
       endif

      endif

      ELSE

       print *, 'CHEM2PHY_RUN: phy export state ItemCount failed,', RC

      ENDIF

!---------------------------------------------
!* Get Fortran array from gocart export state
!---------------------------------------------

      MESSAGE_CHECK="CHEM2PHY_RUN: Get ItemCount from chem export state"
      call ESMF_StateGet(CHEM_EXP_STATE                   &
                        ,itemcount = item_count_chem      &
                        ,itemnamelist = item_name         &
                        ,rc   =rc)
      CALL ERR_MSG(RC,MESSAGE_CHECK,RC_CPL)

      IF ( RC == ESMF_SUCCESS ) THEN

      if (item_count_chem == 0 ) then

       print *, 'CHEM2PHY_RUN: Empty chem export state; Fortran array not filled'

      else

       if ( run_DU ) then
        call GetPointer_tracer_(CHEM_EXP_STATE,'du001', c_du001, rc)
        call GetPointer_tracer_(CHEM_EXP_STATE,'du002', c_du002, rc)
        call GetPointer_tracer_(CHEM_EXP_STATE,'du003', c_du003, rc)
        call GetPointer_tracer_(CHEM_EXP_STATE,'du004', c_du004, rc)
        call GetPointer_tracer_(CHEM_EXP_STATE,'du005', c_du005, rc)
       endif 

       if ( run_SS ) then
        call GetPointer_tracer_(CHEM_EXP_STATE,'ss001', c_ss001, rc)
        call GetPointer_tracer_(CHEM_EXP_STATE,'ss002', c_ss002, rc)
        call GetPointer_tracer_(CHEM_EXP_STATE,'ss003', c_ss003, rc)
        call GetPointer_tracer_(CHEM_EXP_STATE,'ss004', c_ss004, rc)
        call GetPointer_tracer_(CHEM_EXP_STATE,'ss005', c_ss005, rc)
       endif

       if ( run_SU ) then
        call GetPointer_3D_    (CHEM_EXP_STATE,'MSA', c_msa, rc)
        call GetPointer_tracer_(CHEM_EXP_STATE,'SO4', c_so4, rc)
        call GetPointer_3D_    (CHEM_EXP_STATE,'SO2', c_so2, rc)
        call GetPointer_3D_    (CHEM_EXP_STATE,'DMS', c_dms, rc)
       endif

       if ( run_OC ) then
        call GetPointer_tracer_(CHEM_EXP_STATE,'OCphobic', c_ocphobic, rc)
        call GetPointer_tracer_(CHEM_EXP_STATE,'OCphilic', c_ocphilic, rc)
       endif

       if ( run_BC ) then
        call GetPointer_tracer_(CHEM_EXP_STATE,'BCphobic', c_bcphobic, rc)
        call GetPointer_tracer_(CHEM_EXP_STATE,'BCphilic', c_bcphilic, rc)
       endif

      endif

      ELSE

       print *, 'CHEM2PHY_RUN: chem export state ItemCount failed,', RC

      ENDIF


!---------------------------------------------
!* Do the actual coupling 
!---------------------------------------------
! 
      IF ( RC_CPL == ESMF_SUCCESS ) THEN

       if (item_count_chem==0 .or. item_count_phys==0) then

        print *, 'CHEM2PHY_RUN: Empty state; Coupling phy_exp with chem_exp skipped'

       else

!
! ---  data copy between phy export state and chem export state

        if ( run_DU ) then
          p_du001(:,:,1:km) = c_du001(:,:,km:1:-1) 
          p_du002(:,:,1:km) = c_du002(:,:,km:1:-1) 
          p_du003(:,:,1:km) = c_du003(:,:,km:1:-1) 
          p_du004(:,:,1:km) = c_du004(:,:,km:1:-1) 
          p_du005(:,:,1:km) = c_du005(:,:,km:1:-1) 
        endif

        if ( run_SS ) then
          p_ss001(:,:,1:km) = c_ss001(:,:,km:1:-1) 
          p_ss002(:,:,1:km) = c_ss002(:,:,km:1:-1) 
          p_ss003(:,:,1:km) = c_ss003(:,:,km:1:-1) 
          p_ss004(:,:,1:km) = c_ss004(:,:,km:1:-1) 
          p_ss005(:,:,1:km) = c_ss005(:,:,km:1:-1) 
        endif

        if ( run_BC ) then
          p_bcphilic(:,:,1:km) = c_bcphilic(:,:,km:1:-1) 
          p_bcphobic(:,:,1:km) = c_bcphobic(:,:,km:1:-1) 
        endif
        if ( run_OC ) then
          p_ocphilic(:,:,1:km) = c_ocphilic(:,:,km:1:-1) 
          p_ocphobic(:,:,1:km) = c_ocphobic(:,:,km:1:-1) 
        endif
        if ( run_SU ) then
          p_msa(:,:,1:km) = c_msa(:,:,km:1:-1) 
          p_so2(:,:,1:km) = c_so2(:,:,km:1:-1) 
          p_so4(:,:,1:km) = c_so4(:,:,km:1:-1) 
          p_dms(:,:,1:km) = c_dms(:,:,km:1:-1) 
        endif

       endif

      ELSE

       print *, 'CHEM2PHY_RUN: Coupling phy_exp with chem_exp skipped'

      ENDIF

!
!-----------------------------------------------------------------------
!***  Check the final error signal variable 
!-----------------------------------------------------------------------
!
      IF(RC_CPL==ESMF_SUCCESS)THEN
        WRITE(0,*)'CHEM2PHY CPL RUN SUCCEEDED'
      ELSE
        WRITE(0,*)'CHEM2PHY CPL RUN FAILED RC_CPL=',RC_CPL
      ENDIF
!! 
      END subroutine run

      END module atmos_chem_phy_cpl_comp_mod
